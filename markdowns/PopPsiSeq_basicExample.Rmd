---
title: "Basic PopPsiSeq Example"
author: "Charlie Soeder"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    toc_depth: 5
    number_sections: true
  html_document: default
bibliography: references.bib
---

```{r setup, include=FALSE}
require("knitr")
knitr::opts_chunk$set(echo = T)
#knitr::opts_knit$set(root.dir='/proj/cdjones_lab/csoeder/PopPsiSeq/')
knitr::opts_knit$set(root.dir=normalizePath("/proj/cdjones_lab/csoeder/pTest/PopPsiSeq/"))

#knitr::opts_chunk$set(root.dir='/proj/cdjones_lab/csoeder/PopPsiSeq/')
#knitr::opts_knit$set(root.dir=peaDubDee)
```

```{r dependencies, include=FALSE}

library("tidyverse")
#require(devtools)
#install_version("ggplot2", version = "3.1.0", repos = "http://cran.us.r-project.org")
library("knitr")
library("gt")
library("yaml")
library("ggbio")
library("readr")
library("reshape2")
library("ggdendro")
library("dendextend")
library("grid")
library("gridExtra")
#library("gtable")
library("rtracklayer")

library("patchwork")
library("ggplotify")
library("ggrepel")
library("ggarchery")

library("patchwork")

# gotta set the working directory.....
#knitr::opts_knit$set(root.dir='/proj/cdjones_lab/csoeder/PopPsiSeq/')


```

```{r initialize, include=FALSE}
print(getwd())
# 
human_readable_croncher <- function(num_in) {
	dig <- 3
	num_out <- formatC(num_in, digits=dig, format='g') %>% as.numeric() %>% sitools::f2si()
	return(num_out)
}

bam_summary_loader <- function(filename, aligner="bwa", reference='dm6'){
	
	tmp.df <- read_delim(filename, "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
	names(tmp.df) <- c("sample","measure","value")
	
	tmp.df$sample <- as.factor(tmp.df$sample)
	tmp.df$measure <- as.factor(tmp.df$measure)
	tmp.df$aligner <- as.factor(aligner)
	tmp.df$reference <- as.factor(reference)
	
	return(tmp.df)
	
}


psiSeq_loader <- function(filename){
  
  windowedPsiSeq.bg <- import.bedGraph(filename)#, genome=refgen)

  names( mcols( windowedPsiSeq.bg)) <- c("score", "shared","total")
mcols( windowedPsiSeq.bg)$shared <- as.numeric(mcols(windowedPsiSeq.bg)$shared)
mcols( windowedPsiSeq.bg)$total <- as.numeric(mcols(windowedPsiSeq.bg)$total)
windowedPsiSeq.bg$ratio <-windowedPsiSeq.bg$shared / windowedPsiSeq.bg$total

  return(windowedPsiSeq.bg)
}


freqShift_loader <- function(filename, refgen = "dm6", p1 = "sim", p2= "sec"){
  
  windowedFreqShift.bg <- import.bedGraph(filename)#, genome=refgen)

  enhancement_col <-  paste("sum_",p1,"_deltaF", sep = "")
  depletion_col <- paste("sum_",p2,"_deltaF", sep="")

  names(mcols(windowedFreqShift.bg)) <-  c("score", enhancement_col, depletion_col, "num_snp")


  mcols(windowedFreqShift.bg)[[enhancement_col]] <- as.numeric(mcols(windowedFreqShift.bg)[[enhancement_col]])
  mcols(windowedFreqShift.bg)[[depletion_col]] <- as.numeric(mcols(windowedFreqShift.bg)[[depletion_col]])

  mcols(windowedFreqShift.bg)[[paste("avg_",p1,"_deltaF", sep = "")]] <- mcols(windowedFreqShift.bg)[[enhancement_col]]/windowedFreqShift.bg$num_snp 

  mcols(windowedFreqShift.bg)[[paste("avg_",p2,"_deltaF", sep = "")]] <- mcols(windowedFreqShift.bg)[[depletion_col]]/windowedFreqShift.bg$num_snp 
  windowedFreqShift.bg$win <- seq(1,nrow(mcols(windowedFreqShift.bg)))

  return(windowedFreqShift.bg)
}



tbl_cnt <- 0
fig_cnt <- 0

print(getwd())
trammel <- read_yaml("configurations/config.basicExample.yaml")
  

```

# Introduction

In evolve and resequence experiments, candidate locii are identified by selecting for a trait of interest and then comparing the genomes of the selected population to those which did not experience selection.

PsiSeq (@Earley2011) was a bioinformatic package written for evolve & resequence experiments, being originally applied to food preference in Drosophila sechellia. In particular, it identified two candidate regions on chromosome 2L.

![region of interest identified in Earley 2011](the_chr2L_anomaly.jpeg)

The current project aims to

-   present an updated bioinformatic workflow
-   revisit & reinterpret the results from @Earley2011

## PsiSeq

The workflow published in @Earley2011, PsiSeq, uses a perl script to directly compare read alignments (as mpileup files) between "control" and selected treatments. The scripts included have minor modifications over the original, such as handling edge cases without error.

Control is in quotes because the original paper actually uses simulated reads generated by fragmenting a reference genome. (The workflow could easily be run on real reads from a sequencer, but this experiment was done in the early, expensive days of high-throughput sequencing)

## PopPsiSeq

The alignment comparison scripts of PsiSeq 1 is essentially a variant caller which identifies sites that mismatch the reference genome to a large degree. This was reasonable for its time but has been rendered obsolete by the development of more sophisticated variant calling algorithms; PopPsiSeq was built around FreeBayes (@Garrison2012). This allows the comparison of groups (eg, replicates of a treatment) whereas earlier comparisons were on an individual basis.

Earlier comparisons were also based on the presence or absence of a fixed variant. By working on a population level, PopPsiSeq is able to use difference in allele frequency between groups (of which fixation is an extreme case). This will hopefully increase statistical power and allow examination of eg polygenic traits.


# Materials, Methods, Data, Software

## Reference Genomes

```{r load_reference_genome_info, include=FALSE, echo=FALSE}
ref_genomes.cfg.df <- plyr::ldply(trammel$reference_genomes, data.frame)

reference_genomes_summary.df  <- read_delim("data/summaries/reference_genomes/reference_genomes.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)

names(reference_genomes_summary.df) <- c("refGenome","measure","value")
```

The droSim1 and droSec1 reference genomes were downloaded in FASTA format from UCSC Genome Browser. These were in the 140-170Mb range, with the droSec1 relatively unconsolidated.

There were questions about the quality of the droSec1 reference and its impact on results; hence, the \_\_\_ sechellia reference genomes were also used (@cite)

```{r "woot woot", echo=FALSE}

tbl_cnt <- tbl_cnt +1


reference_genomes_summary.df %>% spread(key=measure, value = value) %>% gt()  %>% tab_header(title=paste("Table ",tbl_cnt, ". Size and Consolidation of Reference Genomes", sep = ""), subtitle=" ") %>%   fmt_number(columns = c(number_contigs, number_bases), suffixing = TRUE, decimals=0) %>% cols_label(refGenome = " ", number_bases = "# bases", number_contigs= "# contigs")


```

(add a by-chromosome breakdown for droSim and a histogram for droSec?)

## Sequenced Reads

```{r include=FALSE}
data_sets.df <- plyr::ldply(trammel$data_sets, data.frame)
data_sets.df$name <- as.factor(data_sets.df$name)
data_sets.df$paired<- as.factor(data_sets.df$paired)
data_sets.df$experimental<- as.factor(data_sets.df$experimental)
data_sets.df$species<- as.factor(data_sets.df$species)
data_sets.df$source<- as.factor(data_sets.df$source)
```

### sources


```{r echo=FALSE}
tbl_cnt <- tbl_cnt +1

data_sets.df %>% filter(subgroups == "all")  %>%  select(c(name,experimental))%>% group_by(experimental) %>% gt() %>%  tab_header(title=paste("Table ",tbl_cnt, "a. Simulans/Sechellia Backcross Experiment: Sample Details", sep = ""), subtitle=" ") 



```

```{r echo=FALSE}
tbl_cnt <- tbl_cnt +1

data_sets.df %>% filter(subgroups == "all" )%>%  select(c(name,experimental,subgroups)) %>% group_by(subgroups, experimental) %>% summarise(count = n()) %>% spread(key = experimental, value = count, fill = 0) %>% ungroup()  %>% gt() %>% cols_label("subgroups" = "") %>%  tab_header(title=paste("Table ",tbl_cnt, "b.  Simulans/Sechellia Backcross Experiments: sample counts", sep = ""), subtitle=" ") 



```


#### Eric's Simulans/Sechellia Hybrids

A backcross and introgression experiment was performed, in which simulans females were mated with sechellia males, and the hybrid offspring were selected for avoidance of morinda odorants. The offspring were sequenced after 15 rounds of backcrossing and introgression [@Earley2011]. One sample was sequenced in this experiment; a follow-up experiment generated three more samples with two replicates each.

```{r echo=FALSE}
tbl_cnt <- tbl_cnt +1

data_sets.df %>% filter(subgroups == "all" )  %>%  select(c(name,experimental,subgroups)) %>% group_by(subgroups, experimental) %>% gt() %>% sub_missing(columns = everything(), rows = everything(), missing_text = "-") %>% cols_label("name" = "") %>%  tab_header(title=paste("Table ",tbl_cnt, ". Backcross Experiments: sample details", sep = ""), subtitle=" ") 



```


#### Simulated

PsiSeq (@Earley2011) used simulated reads as ersatz controls; these were generated by fragmenting the reference genome to specified coverage depth and read size, and optionally adding random errors. 

```         
#written by W. Jeck 2007; modified by E. Earley 2011
#UNC at Chapel Hill, NC; Dept. Biology; Corbin Jones Lab
```


### Pre-processing

```{r echo=FALSE, include=FALSE}
fastp_summary <- read_delim("data/summaries/intermediate/FASTP/all.sequenced_reads.dat", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(fastp_summary ) <- c("name","type","measure","value")
fastp_summary$name <- as.factor(fastp_summary$name)
fastp_summary$type <- as.factor(fastp_summary$type)
fastp_summary$measure <- as.factor(fastp_summary$measure)
```

```{r echo=FALSE, include=FALSE}
filtration_stats <- inner_join(fastp_summary %>%  filter(type=="prefiltered" | type == 'postfiltered'), data_sets.df, by=c("name"="name"))
filtration_stats$type <- factor(filtration_stats$type, levels=c("prefiltered", "postfiltered"))
```

These reads were preprocessed with FASTP [@Chen2018] for quality control and analytics.

Starting FASTQ files contained a total of $`r sum( filtration_stats %>% filter(type =='prefiltered') %>% filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$ reads; after QC, this dropped to $`r sum( filtration_stats %>% filter(type =='postfiltered') %>% filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$.

```{r echo=FALSE}
pre_post_counts <- filtration_stats %>% filter(measure=='total_reads') %>%  group_by(type)  %>%  summarise(minimum = min(value), average=mean(value) , maximum = max(value)) 
retention_percent <- filtration_stats %>% filter(measure=='total_reads') %>%  filter(subgroups=="all")%>% select(c(name,type,value)) %>%  spread(type,value) %>% mutate(retention=100*postfiltered/prefiltered) %>%  summarise(type='percent retention', minimum = min(retention), average=mean(retention) , maximum = max(retention))
```

```{r echo=FALSE}
tbl_cnt <- tbl_cnt +1
rbind(pre_post_counts, retention_percent)  %>% gt()  %>% tab_header(title=paste("Table ",tbl_cnt, ". Read Retention Rate during Preprocessing", sep = ""), subtitle= md("&nbsp;")) %>%  fmt_number(columns = c(minimum, average,maximum),suffixing = TRUE, decimals=0) %>% cols_label(type=" ")
```

Filtration also increased the read quality, as seen in the increase in the fraction of reads with an average quality score \> 30 :

```{r echo=FALSE}
fig_cnt <- fig_cnt +1
ggplot(filtration_stats %>% filter(measure == "q30_rate")%>% filter(subgroups == "all")) + geom_line(aes(group=name, x=type,y=100*value)) +  geom_point(aes(x=type, y = 100*value, color=experimental)) + labs(title = paste("Figure ", fig_cnt, ". Percent of Reads with a mean QUAL > 30",sep = ""), y="Percent QUAL > 30", x="") + theme_clear()

```

Duplicate reads were also detected; these will be filtered during alignment:

```{r echo=FALSE, include=FALSE}
dupe_stats <- inner_join(fastp_summary %>% filter(type=='duplication' & measure =='rate') %>%  mutate(percent=value*100) %>% select(c(name,percent)), data_sets.df, by=c("name"="name"))
```

```{r echo=FALSE}
tbl_cnt <- tbl_cnt + 1

duplicationStats.gt <- dupe_stats %>%  summarise(minimum = min(percent), average=mean(percent), median=median(percent) , maximum = max(percent)) %>% gt() %>% tab_header(title=paste("Table ",tbl_cnt, ". Percentage Duplication", sep = ""), subtitle="FASTP estimate") %>% fmt_number(columns=c(minimum,median,average,maximum), decimals=1, )

duplicationStats.gt

#write(duplicationStats.gt %>%  as_raw_html(), paste("results/tables/tbl",tbl_cnt,"_duplicationStats.html", sep=""))


```

```{r echo=FALSE}
fig_cnt <- fig_cnt + 1
ggplot(dupe_stats) + geom_histogram(aes(x=percent), bins=15) + labs(title=paste("Figure ",fig_cnt, ". Duplication Histogram", sep = ""), x="Read Duplication Rate (FASTP estimate)", y="Number Samples") + theme_clear()
```

## Mapped Reads

Reads were first mapped to a reference genome using the BWA SAMPE/SE algorithm. Then, the alignment file was filtered for uniqueness (ie, a read must be aligned optimally with no alternative or runner-up hits,

```         
"XT:A:U.*X0:i:1.*X1:i:0"
```

, mapping/sequencing quality,

```         
-q 20 -F 0x0100 -F 0x0200 -F 0x0300 -F 0x04
```

, and deduplication.

```{r echo=FALSE, include=FALSE}
vs_droSim1.bwa <- bam_summary_loader(filename = "data/summaries/intermediate/BAMs/all.vs_droSim1.bwa.summary",aligner="bwa", reference="droSim1")

vs_dm6.bwa <- bam_summary_loader(filename = "data/summaries/intermediate/BAMs/all.vs_dm6.bwa.summary",aligner="bwa", reference="dm6")

vs_droSim1.bwaUniq <- bam_summary_loader(filename = "data/summaries/intermediate/BAMs/all.vs_droSim1.bwaUniq.summary",aligner="bwaUniq", reference="droSim1")

vs_dm6.bwaUniq <- bam_summary_loader(filename = "data/summaries/intermediate/BAMs/all.vs_dm6.bwaUniq.summary",aligner="bwaUniq", reference="dm6")



#all_alignments <- rbind(vs_droSim1.bwa,vs_dm6.bwa,vs_droSim1.bwaUniq,vs_dm6.bwaUniq)
all_alignments <- rbind(vs_dm6.bwa,vs_dm6.bwaUniq)



```

### Read & Alignment Quality

```{r echo=FALSE}

#before_After.counts <- rbind(vs_droSim1.bwa %>%  filter(measure=='total_read_count' | measure == 'total_mapped_count'), vs_droSim1.bwaUniq %>%  filter( measure == 'total_mapped_count') %>% mutate(measure='filtered_mapped_count'))

#before_After.counts$measure <- factor(before_After.counts$measure, levels = c('total_read_count','total_mapped_count','filtered_mapped_count'))

#ggplot(before_After.counts) + geom_line(aes(group=sample, x=measure,y=value)) + geom_line(aes(group=sample, x=measure,y=value)) + geom_point(aes(x=measure, y=value, group=sample,color=sample)) + labs(title="Read Counts by Processing Step: Raw, Mapped, Filtered", x="", y="Number Reads" ) + scale_y_log10()



readcount_process <- all_alignments %>%  filter( (measure=='total_read_count' & aligner=="bwa") | measure == 'total_mapped_count' ) %>% mutate(measure=ifelse(aligner=="bwaUniq", "filtered_mapped_count", ifelse(measure=="total_read_count","total_read_count","total_mapped_count"))) 
readcount_process$measure <- factor(readcount_process$measure, levels = c('total_read_count','total_mapped_count','filtered_mapped_count'))

fig_cnt <- fig_cnt + 1

ggplot( inner_join(readcount_process,data_sets.df %>% filter(subgroups == "all"), by=c("sample"="name"))) + geom_line(aes(group=sample, x=measure,y=value)) + geom_point(aes(x=measure, y=value, group=sample, color = experimental))+ facet_grid(reference~.) + labs(title=paste("Figure ", fig_cnt, ". Read Counts by Processing Step: Unmapped, Mapped, Filtered",sep=""), x="", y="Number Reads" ) + scale_y_log10()  + theme_clear() + theme(axis.text.x = element_text(angle = -45, hjust = 0)) #+ theme(legend.position = "none")

```

```{r echo=FALSE}

readcount_process.spread <- readcount_process %>% select(-c(aligner)) %>%  spread(measure, value) %>%  mutate(mapping_retention=total_mapped_count/total_read_count, filter_retention = filtered_mapped_count/total_mapped_count)


tbl_cnt <- tbl_cnt + 1


readcount_process.spread %>% gather(total_read_count:filtered_mapped_count, key="measure", value="value") %>%  group_by(reference, measure ) %>% summarise(minimum = min(value), average=mean(value), median = median(value), maximum = max(value)) %>%  gt()  %>% tab_header(title=paste("Table ",tbl_cnt, "a. Mapping retention", sep = ""), subtitle="readcounts as the reads are mapped") %>% fmt_number(columns=c(minimum,median,average,maximum), decimals=1, suffixing = T)







```

The fraction of reads retained at each point:

```{r echo=FALSE}


#tbl_cnt <- tbl_cnt + 1


readcount_process.spread %>% gather(mapping_retention:filter_retention, key="measure", value="value") %>%  group_by(measure) %>% summarise(minimum = min(value), average=mean(value), median = median(value), maximum = max(value)) %>%  gt()  %>% tab_header(title=paste("Table ",tbl_cnt, "b. Mapping retention", sep = ""), subtitle="Percentage of Reads Retained at Each Step") %>% fmt_percent(columns=c(minimum,median,average,maximum), decimals=1)


```

### Depth & Breadth of Coverage

```{r echo=FALSE, include=FALSE}

before_After.cov <- inner_join( vs_droSim1.bwa %>%  filter(measure=='avg_depth' | measure == 'total_breadth') %>% select(-c(aligner)) %>% spread(measure, value), vs_droSim1.bwaUniq %>%  filter(measure=='avg_depth' | measure == 'total_breadth') %>% select(-c(aligner)) %>% spread(measure, value), by='sample', suffix=c(".before",".after") ) %>%  mutate(depth_retention = avg_depth.after/avg_depth.before, breadth_retention=total_breadth.after/total_breadth.before)


before_After.cov.gathered.meta <- inner_join(before_After.cov %>%  gather(avg_depth.before:breadth_retention, key="measure", value="value") , data_sets.df, by=c("sample"="name") ) 


```

Depth of coverage, ie, the genome-wide average number of mapped reads per base pair:

```{r echo=FALSE}

depth.process <- all_alignments  %>%  filter(measure=='avg_depth' )%>% spread(aligner, value) %>%  mutate(depth_retention = bwaUniq/bwa) %>% rename( bwa = "before", bwaUniq = "after")

covstats.dpth <- depth.process %>% group_by(reference)%>% summarise(step="pre-filtration depth",minimum = min(before), average=mean(before), median = median(before), maximum = max(before))

covstats.dpth <- rbind(covstats.dpth, depth.process  %>% group_by(reference)%>% summarise(step="post-filtration depth",minimum = min(after), average=mean(after), median = median(after), maximum = max(after)))

covstats.dpth <- rbind(covstats.dpth, depth.process  %>% group_by(reference) %>% summarise(step="depth retention percent",minimum = min(depth_retention), average=mean(depth_retention), median = median(depth_retention), maximum = max(depth_retention)))

# %>% kable(caption="", digits=1 )



tbl_cnt <- tbl_cnt + 1


covstats.dpth %>% group_by(step)  %>%  gt() %>% fmt_number(columns = c(minimum, average, median, maximum), decimals = 1, rows = step != "depth retention percent") %>% fmt_percent(columns=c(minimum,median,average,maximum), rows = step == "depth retention percent",  decimals=1) %>% tab_header(title=paste("Table ",tbl_cnt, ". Depth of Coverage Statistics for Raw and Filtered Alignments", sep = ""), subtitle="bwa, bwaUniq") 




```

```{r echo=FALSE}


fig_cnt <- fig_cnt + 1
ggplot(depth.process %>%  select(-c(depth_retention,measure)) %>%  gather(before:after, key=measure, value=value) %>% mutate(measure=factor(measure, levels=c("before","after"))) ) +geom_line(aes(group=sample, x=measure,y=value))+ geom_point(aes(group=sample, x=measure,y=value, color=sample))  + facet_grid(.~reference) + labs(title=paste("Figure ", fig_cnt, ". Depth Of Coverage for Raw and Filtered Alignments", sep=""), x="", y="Reads Per BP, Genome-Wide" ) + theme_bw() + theme(legend.position = "none")


```

Breadth of coverage, ie, the percentage of the genome covered by at least one read:

```{r echo=FALSE, include=FALSE}
breadth.process <- all_alignments %>%  filter(measure=='total_breadth' ) %>% spread(aligner, value) %>%  mutate(breadth_retention = 100*bwaUniq/bwa) %>% rename(bwa = "before", bwaUniq="after")

covstats.brdth <- breadth.process %>% summarise(step="pre-filtration breadth",minimum = 100*min(before), average=100*mean(before), median = 100*median(before), maximum = 100*max(before))

covstats.brdth <- rbind(covstats.brdth, breadth.process %>% summarise(step="post-filtration breadth",minimum = 100*min(after), average=100*mean(after), median = 100*median(after), maximum = 100*max(after)))

covstats.brdth <- rbind(covstats.brdth, breadth.process  %>% summarise(step="breadth retention percent",minimum = min(breadth_retention), average=mean(breadth_retention), median = median(breadth_retention), maximum = max(breadth_retention)))

covstats.brdth %>% kable(caption="Breadth of Coverage Statistics for Raw and Filtered Alignments", digits=1 )

```

```{r echo=FALSE, include=TRUE}

fig_cnt <- fig_cnt + 1

ggplot(breadth.process %>%  select(-c(breadth_retention, measure)) %>%  gather(before:after, key=measure, value=value) %>% mutate(measure=factor(measure, levels=c("before","after")), value=100*value) ) + geom_point(aes(group=sample, x=measure,y=value)) + geom_line(aes(group=sample, x=measure,y=value)) + facet_grid(.~reference) + labs(title= paste("Figure ",fig_cnt,". Breadth Of Coverage for Raw and Filtered Alignments", sep=""), x="", y="Percentage of Reference Genome Mapped To" )+ theme_bw()+ theme(legend.position = "none")


```

## Called Variants

BWAUniq mappings were used to jointly call variants in VCF format via Freebayes [@Garrison2012] using standard filters.

```{r echo=FALSE, include=FALSE}

#all_samples.bwaUniq.vs_dm6.calledVariants.summaryStats <- read_delim("data/summaries/intermediate/VCFs/all.calledVariants.bwaUniq.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
all_samples.bwaUniq.vs_dm6.calledVariants.summaryStats <- read_delim("data/summaries/intermediate/VCFs/dm6/freebayes/all.vs_dm6.bwaUniq.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(all_samples.bwaUniq.vs_dm6.calledVariants.summaryStats) <-c("group", "refGenome","measure","value")

reference_genomes_summary.sprud.df <- reference_genomes_summary.df %>%  spread(measure,value) %>%  select(c(-number_contigs)) 

all_samples.bwaUniq.calledVariants.summaryStats.df <- all_samples.bwaUniq.vs_dm6.calledVariants.summaryStats

all_samples.calledVariants.snpCount.df <- inner_join(all_samples.bwaUniq.calledVariants.summaryStats.df  %>%  filter(measure=="total_snp_count") %>% spread(measure, value) , reference_genomes_summary.sprud.df, by=c("refGenome"="refGenome"))

```

```{r echo=FALSE}

all_samples.calledVariants.snpCount.gt <- all_samples.calledVariants.snpCount.df %>%  mutate(snp_rate=1000*total_snp_count/number_bases, total_snp_count=human_readable_croncher(total_snp_count), number_bases=human_readable_croncher(number_bases) ) %>% select(-c(group))  %>% select(c(refGenome, number_bases, total_snp_count, snp_rate))  %>% gt() %>% fmt_number(snp_rate, decimals = 1) %>% cols_label(number_bases="Genome Size (bp)" , total_snp_count = "# SNPs", snp_rate = "SNP rate (per kb)") %>% tab_header(title=paste("Table ",tbl_cnt, ". SNP count and per-KB SNP rate across all samples", sep = ""), subtitle="") 

all_samples.calledVariants.snpCount.gt

```

To build this VCF, `r nrow(data_sets.df)` samples called jointly. However, not all sites were called in all samples (eg, due to coverage differences). The sites had the following group-wide call rate:

```{r echo=FALSE, include=FALSE}

all_samples_vs_irvineSec.lmiss <- read_delim("data/summaries/intermediate/VCFs/irvineSec/all.vs_irvineSec.bwaUniq.summary.lmiss", "\t", escape_double = FALSE, trim_ws = TRUE)
all_samples_vs_irvineSec.lmiss$refgenome <- "irvineSec"

all_samples_vs_droSim1.lmiss <- read_delim("data/summaries/intermediate/VCFs/droSim1/all.vs_droSim1.bwaUniq.summary.lmiss", "\t", escape_double = FALSE, trim_ws = TRUE)
all_samples_vs_droSim1.lmiss$refgenome <- "droSim1"


all_samples_vs_dm6.lmiss <- read_delim("data/summaries/intermediate/VCFs/dm6/all.vs_dm6.bwaUniq.summary.lmiss", "\t", escape_double = FALSE, trim_ws = TRUE)
all_samples_vs_dm6.lmiss$refgenome <- "dm6"

nsamps <- nrow(data_sets.df)


all_samples.lmiss <- rbind(all_samples_vs_droSim1.lmiss, all_samples_vs_irvineSec.lmiss, all_samples_vs_dm6.lmiss) %>% select(c(refgenome, N_MISS)) %>%  mutate(refgenome=as.factor(refgenome), N_PRES=nsamps-N_MISS)

```

```{r echo=FALSE, warning=FALSE}
fig_cnt <- fig_cnt + 1
ggplot(all_samples.lmiss) + geom_freqpoly(aes(x=N_PRES, group=refgenome, color=refgenome), bins=nsamps) + scale_x_continuous(name ="Number Samples",limits=c(1,nsamps), breaks =seq(1,nsamps,10)) + theme_clear() + labs(title=paste("Figure ",fig_cnt,". Histogram of SNPs by Number of Samples Called At Site",sep=""), y="Number of Sites")
```

The fraction of jointly called SNPs which are individually callable:

```{r echo=FALSE, include=FALSE}
all_samples_vs_irvineSec.imiss <- read_delim("data/summaries/intermediate/VCFs/irvineSec/all.vs_irvineSec.bwaUniq.summary.imiss", "\t", escape_double = FALSE, trim_ws = TRUE)
all_samples_vs_irvineSec.imiss$refgenome <- "irvineSec"

all_samples_vs_droSim1.imiss <- read_delim("data/summaries/intermediate/VCFs/droSim1/all.vs_droSim1.bwaUniq.summary.imiss", "\t", escape_double = FALSE, trim_ws = TRUE)
all_samples_vs_droSim1.imiss$refgenome <- "droSim1"



all_samples_vs_dm6.imiss <- read_delim("data/summaries/intermediate/VCFs/dm6/all.vs_dm6.bwaUniq.summary.imiss", "\t", escape_double = FALSE, trim_ws = TRUE)
all_samples_vs_dm6.imiss$refgenome <- "dm6"




all_samples.imiss  <- rbind(all_samples_vs_irvineSec.imiss, all_samples_vs_droSim1.imiss, all_samples_vs_dm6.imiss)  %>%  mutate(name=as.factor(INDV), refgenome=as.factor(refgenome), N_PRES=N_DATA-N_MISS) %>% select(c( name, N_MISS, N_PRES, F_MISS,refgenome))


```

```{r echo=FALSE}

all_samples.imiss.augmented <- inner_join(all_samples.imiss, breadth.process %>%  select(c(sample,reference,after)) %>% rename(after="breadth")%>% mutate(breadth = 100*breadth), by=c("name"="sample", "refgenome"="reference"))


all_samples.imiss.augmented <-inner_join(all_samples.imiss.augmented, depth.process %>%  select(c(sample,reference,after)) %>% rename(after="depth"), by=c("name"="sample", "refgenome"="reference"))

all_samples.imiss.augmented <- all_samples.imiss.augmented %>%  gather(breadth:depth, key="measure", value="value")

```

```{r echo=FALSE}
fig_cnt <- fig_cnt + 1

ggplot(all_samples.imiss.augmented) + geom_line(aes(x=value, y=1-F_MISS, group=name), alpha = .8 ) + geom_point(aes(x= value, y=1-F_MISS, color=refgenome)) + facet_grid(.~measure, scales="free_x") + theme_clear() + labs(x="", y="Fraction of SNPs Callable", title= paste("Figure ", fig_cnt, ". Jointly Called SNPs Callable per Sample", sep = ""), subtitle = "by Breadth and Depth of Coverage") 

#+ geom_text(data=subset(all_samples.imiss.augmented, 1-F_MISS < 0.75 & measure=="breadth"),aes(value,1-F_MISS,label=name))
#+ 
```

Of some concern is the generally low callability among wild-caught d. simulans:

```{r echo=FALSE}
fig_cnt <- fig_cnt + 1




ggplot( inner_join( all_samples.imiss.augmented %>% filter(measure == "breadth" & refgenome == "dm6") , data_sets.df  , by = c("name"="name")) ) + geom_point( data = . %>% filter(subgroups == "wildSim") , aes(x= value, y=1-F_MISS) , color="blue", size = 2.5 )  + geom_point( data = . %>% filter(subgroups == "labSim")  , aes(x= value, y=1-F_MISS) , color="red", size = 2.5 ) + geom_point(data = . %>% filter(subgroups == "all") , aes(x= value, y=1-F_MISS)  , alpha = 1, color = "black")   + geom_hline(yintercept = 0.25, linetype = "dashed") + geom_text_repel(data = . %>% filter(subgroups == "all") %>% filter(1-F_MISS < 0.25), aes(x = value, y = 1-F_MISS, label = name), xlim = c(40,100), ylim = c(0.0, 0.5)) + theme_clear() + labs(x="Coverage Breadth (Percent Genome Covered)", y="Fraction of SNPs Callable", title= paste("Figure ", fig_cnt, "a. Jointly Called SNPs Callable per Sample", sep = ""), subtitle = "wildSim quality control", caption = "red: labSim; blue: wildSim") 

#+ geom_text(data=subset(all_samples.imiss.augmented, 1-F_MISS < 0.75 & measure=="breadth"),aes(value,1-F_MISS,label=name))
#+ 
```

```{r echo=FALSE}


missingSites.wildSimQC.gg <- ggplot( inner_join( all_samples.imiss.augmented %>% filter(measure == "breadth" ) , data_sets.df %>% filter(subgroups == "all"), by = c("name"="name")) ) + geom_vline(xintercept = 0.25, linetype = "dotted", color = "black", alpha = 0.0)+ stat_ecdf( aes(x= 1-F_MISS, color = refgenome), geom = "step") + stat_ecdf( data = inner_join( all_samples.imiss.augmented %>% filter(measure == "breadth" ) , data_sets.df %>% filter(subgroups == "wildSim"), by = c("name"="name")), aes(x= 1-F_MISS, color = refgenome), linetype = "dashed", geom = "step")  + labs(x="Fraction SNPs Called", y="Cumulative Fraction", title= paste("Figure ", fig_cnt, "b. Cumulative Distribution of Jointly Called SNPs Callable per Sample", sep = ""), subtitle="wildSim quality control", caption = "solid: 'all' subgroup; dashed: 'wildSim' subgroup") +theme_clear()
missingSites.wildSimQC.gg

```

```{r echo=FALSE, warning=FALSE}

ggplot( inner_join( all_samples.imiss.augmented %>% filter(measure == "breadth" ) , data_sets.df, by = c("name"="name")) ) + geom_freqpoly(data = . %>% filter(subgroups=="all") %>% mutate(placeholder = "all"), aes(x= 1-F_MISS, color = refgenome), bins=15)  + geom_freqpoly(data = . %>% filter(subgroups=="wildSim") %>% mutate(placeholder = "wildSim"), aes(x= 1-F_MISS, color = refgenome), bins=15) + facet_grid(placeholder~., scales = "free_y")  + theme_clear()  + labs(x="Fraction of SNPs Callable", y="Number of Samples", title= paste("Figure ", fig_cnt, "c. Histogram of Fraction of Jointly called SNPs Which are Callable Per Sample", sep = ""), subtitle = "wildSim quality control") 


#+ 
```

## PsiSeq Algorithm Details

The first two versions of PsiSeq were similar: reads are aligned to a reference genome and the alignments are compared directly using the pileups. Sites were identified which differed in the parent alignments; ancestry was inferred at each such site in the offspring, according to which parents' allele was present, and assigned a 1 for one parent and a zero for the other. These were then averaged by window: a window with a high average score will be enriched in ancestry from parent 1.

The alignment comparison scripts of PsiSeq 1 and 2 are essentially variant callers which identify sites which mismatch the reference genome to a large degree. This was reasonable for its time but has been rendered obsolete by the development of more sophisticated variant calling algorithms; PopPsiSeq was built around FreeBayes (@Garrison2012), though any VCF-outputting program could be used. This allows the comparison of groups (eg, replicates of a treatment) whereas earlier comparisons were on an individual basis.

Earlier comparisons were also based on the presence or absence of a fixed variant. By working on a population level, PopPsiSeq is able to use difference in allele frequency between groups (of which fixation is an extreme case). This will hopefully increase statistical power and allow examination of eg polygenic traits.

### PopPsiSeq

Once the SNPs were called, the VCF file iss split into subsets, eg the sequenced individuals of parent1, sequenced individuals of parent species 2, and the sequenced hybrids. For each SNP still meeting minimum requirments (biallelic, few missing samples), the subset-wide allele frequency was calculated. The frequencies for the two parent species populations were used as reference points, and the distance from the hybrid allele frequency to each parent's allele frequency is calculated for each SNP. The per-window average shift was then calculated.

Here is a hypothetical example: suppose that D sechellia is hybridized with D simulans. At a given site in the genome, 75% of alleles in the sechellia population are T and 25% are A. Suppose in the simulans population, it's 25% T and 75% A. Now, the allele frequency is tallied in three different subgroups:

In the first subgroup, 100% of alleles are T. This subgroup would have a sech-ward shift of +0.25 and a sim-ward shift of -0.75.

In the second subgroup, 50% of alleles are T. This subgroup would have a sech-ward shift of -0.25 and a sim-ward shift of -0.25.

In the third subgroup, 0% of alleles are T and all are A. This subgroup would have a sech-ward shift of -0.75 and a sim-ward shift of +0.25.

```{r echo=FALSE, warning=FALSE, message=FALSE}



illustration.df <- data.frame(example = c(rep("exaggerated sechellia", 3),rep("intermediate", 3),rep("exaggerated simulans", 3)), population =rep(c("simulans", "sechellia", "hybrid"),3), allele_frequency = c(0.25, 0.75, 1, 0.25, 0.75, 0.5, 0.25, 0.75, 0))

illustration.df %<>% spread(key = population, value = allele_frequency) %>% mutate(simward_shift = simulans-hybrid, sechward_shift = hybrid - sechellia) %>% gather(key = "direction", value = "AF_shift", c(simward_shift, sechward_shift)) %>% mutate(example = factor(example, levels = c("exaggerated sechellia","intermediate","exaggerated simulans")))






illustration.gg <- ggplot(illustration.df)  +scale_color_manual(values=c("black","red","blue"))  + facet_wrap( ~ example ) + coord_cartesian(xlim = c(0.8,1.2)) + theme_clear()  

illustration.gg <- illustration.gg + geom_hline( data = . %>% select(c(example, hybrid)) %>%  unique(), aes( yintercept= hybrid ), linetype = "dashed", color = "black")

illustration.gg <- illustration.gg + geom_point( data = . %>% select(c(example, simulans, sechellia, hybrid)) %>%  unique()  %>% gather(key = parent, value = AF, c("simulans", "sechellia", "hybrid")), aes(y= AF , color = parent), x=1,  size = 3) 

illustration.gg <- illustration.gg + geom_hline(aes(yintercept = 0.75), color = "red", linetype = "dashed")+ geom_hline(aes(yintercept = 0.25), color = "blue", linetype = "dashed") 

illustration.gg <- illustration.gg +  geom_arrowsegment(data = . %>% filter(direction == "simward_shift") %>% group_by(example)%>% mutate(arrow_start = max(hybrid, simulans), arrow_end = min(hybrid, simulans)), aes(y = arrow_start, yend =arrow_end) , x = 0.9, xend = 0.9 , color = "blue", arrow_positions =  c(1))


illustration.gg <- illustration.gg +  geom_arrowsegment(data = . %>% filter(direction == "sechward_shift") %>% group_by(example)%>% mutate(arrow_start = min(hybrid, sechellia), arrow_end = max(hybrid, sechellia)), aes(y = arrow_start, yend =arrow_end) , x = 1.1, xend = 1.1 , color = "red", arrow_positions =  c(1))


illustration.gg <- illustration.gg + geom_text( data = data.frame(text = c("simulans AF", "sechellia AF"), x=c(1.1, 0.9), y=c(0.2,0.8), example = c("exaggerated sechellia","exaggerated simulans") , parent = c("simulans", "sechellia")) %>% mutate(example = factor(example)), aes(x = x, y=y, color = parent, label = text) ) 


illustration.gg <- illustration.gg + geom_text( data = illustration.df, aes(label=case_match(direction, "simward_shift" ~ paste("simulans-oriented\nAF shift:",AF_shift), "sechward_shift" ~ paste("sechellia-oriented\nAF shift:",AF_shift)  ), y =case_match(direction, "simward_shift" ~ hybrid + AF_shift, "sechward_shift" ~  hybrid - AF_shift ) , color = case_match(direction, "simward_shift" ~ "simulans", "sechward_shift" ~ "sechellia"), x = case_match(direction, "simward_shift" ~ 0.85, "sechward_shift" ~ 1.15  )), angle = 90) 

#  library(ggfittext)
  
  

illustration.gg <- illustration.gg + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),legend.position="none") + labs(y="")


illustration.loSim.gg <- illustration.gg
 

















illustration.df <- data.frame(example = c(rep("exaggerated simulans", 3),rep("intermediate", 3),rep("exaggerated sechellia", 3)), population =rep(c("sechellia", "simulans", "hybrid"),3), allele_frequency = c(0.25, 0.75, 1, 0.25, 0.75, 0.5, 0.25, 0.75, 0))

illustration.df %<>% spread(key = population, value = allele_frequency) %>% mutate(simward_shift = hybrid-simulans, sechward_shift = sechellia-hybrid ) %>% gather(key = "direction", value = "AF_shift", c(simward_shift, sechward_shift)) %>% mutate(example = factor(example, levels = c("exaggerated sechellia","intermediate","exaggerated simulans")))


illustration.gg <- ggplot(illustration.df)  +scale_color_manual(values=c("black","red","blue"))  + facet_wrap( ~ example ) + coord_cartesian(xlim = c(0.8,1.2)) + theme_clear() + theme( strip.background = element_blank(), strip.text.x = element_blank())



illustration.gg <- illustration.gg + geom_hline( data = . %>% select(c(example, hybrid)) %>%  unique(), aes( yintercept= hybrid ), linetype = "dashed", color = "black")



illustration.gg <- illustration.gg + geom_point( data = . %>% select(c(example, simulans, sechellia, hybrid)) %>%  unique()  %>% gather(key = parent, value = AF, c("simulans", "sechellia", "hybrid")), aes(y= AF , color = parent), x=1,  size = 3) 


illustration.gg <- illustration.gg + geom_hline(aes(yintercept = 0.25), color = "red", linetype = "dashed")+ geom_hline(aes(yintercept = 0.75), color = "blue", linetype = "dashed") 


illustration.gg <- illustration.gg +  geom_arrowsegment(data = . %>% filter(direction == "simward_shift") %>% group_by(example)%>% mutate(arrow_start = min(hybrid, simulans), arrow_end = max(hybrid, simulans)), aes(y = arrow_start, yend =arrow_end) , x = 0.9, xend = 0.9 , color = "blue", arrow_positions =  c(1))



illustration.gg <- illustration.gg +  geom_arrowsegment(data = . %>% filter(direction == "sechward_shift") %>% group_by(example)%>% mutate(arrow_start = max(hybrid, sechellia), arrow_end = min(hybrid, sechellia)), aes(y = arrow_start, yend =arrow_end) , x = 1.1, xend = 1.1 , color = "red", arrow_positions =  c(1))




illustration.gg <- illustration.gg + geom_text( data = data.frame(text = c("simulans AF", "sechellia AF"), x=c( 1.1, 0.9),  y=c(0.8, 0.2), example = c("exaggerated sechellia","exaggerated simulans") , parent = c("simulans", "sechellia")) %>% mutate(example = factor(example)), aes(x = x, y=y, color = parent, label = text) ) 



illustration.gg <- illustration.gg + geom_text( data = illustration.df, aes(label=case_match(direction, "simward_shift" ~ paste("simulans-oriented\nAF shift:",AF_shift), "sechward_shift" ~ paste("sechellia-oriented\nAF shift:",AF_shift)  ), y =case_match(direction, "simward_shift" ~ hybrid - AF_shift, "sechward_shift" ~  hybrid + AF_shift ) , color = case_match(direction, "simward_shift" ~ "simulans", "sechward_shift" ~ "sechellia"), x = case_match(direction, "simward_shift" ~ 0.85, "sechward_shift" ~ 1.15  )), angle = 90) 



illustration.gg <- illustration.gg + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),legend.position="none") + labs(y="")

illustration.hiSim.gg <- illustration.gg


wrap_elements(illustration.loSim.gg/illustration.hiSim.gg)   +  labs(tag = "Allele Frequency (AF)") + theme(plot.tag = element_text(size = rel(1), angle = 90),plot.tag.position = "left" )


```


## Reanalysis of Early 2011

```{r echo=FALSE, warning=FALSE, message=FALSE}

windowedFreqShift.eric2011.labSech.dm6.bg <- freqShift_loader(filename = "data/ultimate/freq_shift/all.Earley2011_with_labSim_and_labSech.vs_dm6.bwaUniq.windowed_w100000_s100000.frqShift.bed", refgen = "dm6", p1 = "sim", p2 = "sec")


windowedFreqShift.eric2011.wildSech.dm6.bg <- freqShift_loader(filename = "data/ultimate/freq_shift/all.Earley2011_with_labSim_and_wildSech.vs_dm6.bwaUniq.windowed_w100000_s100000.frqShift.bed", refgen = "dm6", p1 = "sim", p2 = "sec")

#windowedFreqShift.eric2011.allSech.dm6.bg <- freqShift_loader(filename = "data/ultimate/freq_shift/all.Earley2011_with_allSim_and_allSech.vs_dm6.bwaUniq.windowed_w100000_s100000.frqShift.bed", refgen = "dm6", p1 = "sim", p2 = "sec")

windowedFreqShift.eric2011.allSech.dm6.bg <- freqShift_loader(filename = "data/ultimate/freq_shift/all.Earley2011_with_labSim_and_allSech.vs_dm6.bwaUniq.windowed_w100000_s100000.frqShift.bed", refgen = "dm6", p1 = "sim", p2 = "sec")


windowedFreqShift.eric2011.labSech.dm6.bg$sechellia <- as.factor("lab-reared")
windowedFreqShift.eric2011.wildSech.dm6.bg$sechellia <- as.factor("wild-caught")
windowedFreqShift.eric2011.allSech.dm6.bg$sechellia <- as.factor("all")


windowedFreqShift.eric2011.dm6.bg <- c(windowedFreqShift.eric2011.labSech.dm6.bg, windowedFreqShift.eric2011.wildSech.dm6.bg,windowedFreqShift.eric2011.allSech.dm6.bg)


```

```{r echo=FALSE, warning=FALSE, message=FALSE}
windowedFreqShift.eric2011.dm6.autosomal.bg <- windowedFreqShift.eric2011.dm6.bg[windowedFreqShift.eric2011.dm6.bg@seqnames %in% c('chr2L','chr2R','chr3L','chr3R')]

fig_cnt <- fig_cnt + 1

autoplot(windowedFreqShift.eric2011.dm6.autosomal.bg[windowedFreqShift.eric2011.dm6.autosomal.bg$sechellia == "all"], aes(y=avg_sim_deltaF, group= sechellia), color = "black", geom='line') + facet_wrap(~seqnames, scales = "free_x") + labs(y="Change in Allele Frequency", title = paste("Figure ", fig_cnt, "a. PopPsiSeq Analysis of Earley2011", sep = ""), subtitle = "Shift Towards Simulans Allele (autosomes only)", x = "coordinate (dm6 reference genome)") + theme_clear() + theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

```{r echo=FALSE, warning=FALSE, message=FALSE}



windowedFreqShift.eric2011.dm6.autosomal.chr2L.gg <- autoplot(windowedFreqShift.eric2011.dm6.autosomal.bg[windowedFreqShift.eric2011.dm6.autosomal.bg$sechellia == "all" & windowedFreqShift.eric2011.dm6.autosomal.bg@seqnames == "chr2L"], aes(y=avg_sim_deltaF, group= sechellia), color = "black", geom='line') + labs(y="Change in Allele Frequency", title = paste("Figure ", fig_cnt, "c. PopPsiSeq Analysis of Earley2011", sep = ""), subtitle = "Shift Towards Simulans Allele (chr2L)", x = "coordinate (dm6 reference genome)") + theme_clear() + theme(axis.text.x = element_text(angle = 90, hjust = 1))


windowedFreqShift.eric2011.dm6.autosomal.chr2L.toSech.gg <- autoplot(windowedFreqShift.eric2011.dm6.autosomal.bg[windowedFreqShift.eric2011.dm6.autosomal.bg$sechellia == "all" & windowedFreqShift.eric2011.dm6.autosomal.bg@seqnames == "chr2L"], aes(y=avg_sec_deltaF, group= sechellia), color = "black", geom='line') + labs(y="Change in Allele Frequency", title = paste("Figure ", fig_cnt, "d. PopPsiSeq Analysis of Earley2011", sep = ""), subtitle = "Shift Towards Sechellia Allele (chr2L)", x = "coordinate (dm6 reference genome)") + theme_clear() + theme(axis.text.x = element_text(angle = 90, hjust = 1))



png(height =  800, width = 1300, filename = paste("results/figures/fig",fig_cnt,"c_Earley2011_chr2L_PopPsiSeq_Sim.png", sep=""))
windowedFreqShift.eric2011.dm6.autosomal.chr2L.gg
dev.off()


png(height =  800, width = 1300, filename = paste("results/figures/fig",fig_cnt,"d_Earley2011_chr2L_PopPsiSeq_Sech.png", sep=""))
windowedFreqShift.eric2011.dm6.autosomal.chr2L.toSech.gg
dev.off()

```

```{r echo=FALSE, warning=FALSE, message=FALSE}

autoplot(windowedFreqShift.eric2011.dm6.autosomal.bg[windowedFreqShift.eric2011.dm6.autosomal.bg$sechellia == "all"], aes(y=avg_sec_deltaF, group = sechellia,  color = sechellia), geom='line') + facet_wrap(~seqnames, scales = "free_x") + labs(y="Change in Allele Frequency", title = paste("Figure ", fig_cnt, "b. PopPsiSeq Analysis of Earley2011", sep = ""), subtitle = "Shift Towards Sechellia Allele", caption = "(autosomes only)") + theme_clear() + theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

